<!---*-coding:utf-8 -*-
--Auto updated?
--   Yes
--File:
--   Generator.html
--Author:
--   CreativeCodeCat [wayne6324@gmail.com]
--Github:
--   https://github.com/CreativeCodeCat/
--
--Created:
--   Thu 07 August 2025, 01:46:29 PM [GMT+1]
--Modified:
--   Tue 12 August 2025, 09:30:25 PM [GMT+1]
--
--Description:
--   Cute Fantasy RPG â€“ Player Sprite Creator Tool
--
--Dependencies:
--   HTML, Javascript
-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cute Fantasy RPG â€“ Player Sprite Creator Tool</title>
    <!-- Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="dark-mode">
    <div class="header">
        <label class="btn btn-primary mb-3">
            Select Player Folder
            <input type="file" id="selectFiles" onchange="initializeCharacterAssetsFolder()" style="display: none;"
                multiple webkitdirectory />
        </label>

        <button id="randomize-selection" class="btn btn-secondary mb-3 ml-2" onclick="randomizeSelections()"
            style="display: none;">ðŸŽ² Randomize Outfit</button>

        <label id="animations-number" style="display:none; margin-bottom:8px;">
            <input type="checkbox" id="toggleNumbers" />
            Show animation numbers.
        </label>
        <div id="selection" class="d-flex flex-wrap mb-3"></div>
    </div>

    <div class="containers" style="width: 75%;">
        <div id="animationsBody"></div>
        <div id="animationsTools"></div>
        <div id="animationsCombined"></div>
    </div>

    <div class="containers" style="width: 20%;">
        <!-- Download Button -->
        <div id="export-controls" style="display:none; margin-bottom: 10px; text-align: center; width: 333px;">
            <button id="download-sprite" class="btn btn-success">â¬‡ Download Sprite Sheet â¬‡</button>
        </div>

        <!-- Final Canvas -->
        <div id="final-exported-canvas" style="display:none;">
            <canvas id="final_canvas" class="final_canvas" width="576" height="3584"></canvas>
        </div>

        <!-- Base Sections -->
        <div id="base-sections" style="display: none;">
            <canvas id="body_canvas" class="canvas-style-base" width="576" height="3584"></canvas>
            <canvas id="tools_canvas" class="canvas-style-base" width="576" height="3584"></canvas>
        </div>
    </div>


    <script>
        const bodyCanvas = document.getElementById("body_canvas");
        const bodyCtx = bodyCanvas.getContext("2d");

        const toolsCanvas = document.getElementById("tools_canvas");
        const toolsCtx = toolsCanvas.getContext("2d");

        // Asset arrays
        var playerBase = [[]], chest = [[]], legs = [[]], feet = [[]], hands = [[]],
            hair = [[]], accessories = [[]], mounts = [[]];
        var toolsByFolder = {};
        var selectedToolsFolder = {};

        // Selections
        var selectedPlayerBase = [1], selectedChest = [0], selectedLegs = [0], selectedFeet = [0],
            selectedHands = [0], selectedHair = [0], selectedAccessories = [0], selectedMounts = [0];

        document.getElementById("selectFiles").onchange = function () {
            initializeCharacterAssetsFolder();
        };

        document.getElementById("toggleNumbers").onchange = function () {
            createAnimationFromBodyCanvas();
            createAnimationFromToolsCanvas();
            createCombinedAnimationsPerAnimation();
            createFullExportedCanvasFromActiveAnimations();
        };

        function initializeCharacterAssetsFolder() {
            document.getElementById("export-controls").style.display = "block";
            document.getElementById("animations-number").style.display = "block";
            document.getElementById("final-exported-canvas").style.display = "block";
            document.getElementById("randomize-selection").style.display = "inline-block";

            playerBase = [[]];
            chest = [[]];
            legs = [[]];
            feet = [[]];
            hands = [[]];
            hair = [[]];
            accessories = [[]];
            mounts = [[]];
            toolsByFolder = {};
            selectedToolsFolder = {};

            // ðŸ”¹ Get new files
            const fileInput = document.getElementById("selectFiles");
            const selectedFiles = Array.from(fileInput.files).map(file => ({
                name: file.name,
                path: file.webkitRelativePath,
                file: file
            }));

            // ðŸ”¹ Process new files
            selectedFiles.forEach(composeResource);

            // ðŸ”¹ Sort and rebuild UI
            sort();
            initializeOptions();
            draw();

            // ðŸ”¹ Clear file input so future uploads replace everything
            fileInput.value = "";
        }

        function composeResource(fileObj) {
            const path = fileObj.path.split("/");
            if (!path[path.length - 1].endsWith(".png")) return

            switch (path[1]) {
                case "Player_Base": generateResource(playerBase, fileObj); break;
                case "Chest": generateResource(chest, fileObj); break;
                case "Legs": generateResource(legs, fileObj); break;
                case "Feet": generateResource(feet, fileObj); break;
                case "Hands": generateResource(hands, fileObj); break;
                case "Hair": generateResource(hair, fileObj); break;
                case "Accessories": generateResource(accessories, fileObj); break;
                case "Player_Mounts": generateResource(mounts, fileObj); break;
                case "Tools":
                    const folder = path[2];
                    if (!toolsByFolder[folder]) {
                        toolsByFolder[folder] = [];
                        selectedToolsFolder[folder] = [0];
                    }
                    toolsByFolder[folder].push(fileObj);
                    break;
                default:
                    console.warn("Unrecognized folder:", path[1], "for file:", fileObj.name);
            }
        }

        function generateResource(arr, fileObj) {
            arr[0].push(fileObj);
        }

        function sort() {
            [playerBase, chest, legs, feet, hands, hair, accessories, mounts].forEach(assetGroup => {
                assetGroup.forEach(arr => {
                    arr.sort((a, b) => a.name.localeCompare(b.name));
                    arr.unshift({ name: "none", file: null });
                });
            });

            Object.keys(toolsByFolder).forEach(folder => {
                toolsByFolder[folder].sort((a, b) => a.name.localeCompare(b.name));
                toolsByFolder[folder].unshift({ name: "none", file: null });
            });
        }

        function getRandomSelection(arr) {
            if (!arr || !arr[0] || arr[0].length <= 1) return [0]; // If no valid options, return 'none'
            const options = arr[0];
            const randomIndex = Math.floor(Math.random() * (options.length - 1)) + 1;
            return [randomIndex];
        }

        function getRandomToolSelections(toolsArr) {
            if (!toolsArr || toolsArr.length <= 1) return [0];
            const randomIndex = Math.floor(Math.random() * toolsArr.length);
            return [randomIndex];
        }

        function getRandomAccessoriesSelection(arr) {
            if (!arr || !arr[0] || arr[0].length <= 1) return [0]; // If no valid options, return 'none'
            const options = arr[0];
            const randomIndex = Math.floor(Math.random() * options.length);
            return [randomIndex];
        }

        function randomizeSelections() {
            selectedPlayerBase = getRandomSelection(playerBase);
            selectedChest = getRandomSelection(chest);
            selectedLegs = getRandomSelection(legs);
            selectedFeet = getRandomSelection(feet);
            selectedHands = getRandomSelection(hands);
            selectedHair = getRandomSelection(hair);
            selectedAccessories = getRandomAccessoriesSelection(accessories);
            selectedMounts = getRandomSelection(mounts);

            // Object.keys(toolsByFolder).forEach(folder => {
            //     selectedToolsFolder[folder] = getRandomToolSelections(toolsByFolder[folder]);
            // });

            // Update all the <select> elements to reflect the new selections
            function updateSelect(id, selectedArr) {
                const select = document.getElementById(id);
                if (select) {
                    Array.from(select.options).forEach((option, i) => {
                        option.selected = selectedArr.includes(parseInt(option.value));
                    });
                }
            }

            updateSelect("selectedPlayerBase", selectedPlayerBase);
            updateSelect("selectedChest", selectedChest);
            updateSelect("selectedLegs", selectedLegs);
            updateSelect("selectedFeet", selectedFeet);
            updateSelect("selectedHands", selectedHands);
            updateSelect("selectedHair", selectedHair);
            updateSelect("selectedAccessories", selectedAccessories);
            updateSelect("selectedMounts", selectedMounts);

            // Object.keys(toolsByFolder).forEach(folder => {
            //     updateSelect(`selectedToolsFolder_${folder}`, selectedToolsFolder[folder]);
            // });

            draw();
        }

        function initializeOptions() {
            const div = document.getElementById("selection");
            div.innerHTML = '';

            function addOptionGroup(label, arr, selectedVar, id) {
                div.appendChild(renderOptionGroup(label, arr[0].map(x => x.name), id, selectedVar, function (e) {
                    if (id.startsWith("selectedToolsFolder_")) {
                        const folderName = id.replace("selectedToolsFolder_", "");
                        selectedToolsFolder[folderName] = Array.from(e.target.selectedOptions).map(opt => parseInt(opt.value));
                    } else {
                        window[id] = Array.from(e.target.selectedOptions).map(opt => parseInt(opt.value));
                    }
                    draw();
                }));
            }

            addOptionGroup("Player Base", playerBase, selectedPlayerBase, "selectedPlayerBase");
            addOptionGroup("Chest", chest, selectedChest, "selectedChest");
            addOptionGroup("Legs", legs, selectedLegs, "selectedLegs");
            addOptionGroup("Feet", feet, selectedFeet, "selectedFeet");
            addOptionGroup("Hands", hands, selectedHands, "selectedHands");
            addOptionGroup("Hair", hair, selectedHair, "selectedHair");
            addOptionGroup("Accessories", accessories, selectedAccessories, "selectedAccessories");
            addOptionGroup("Mounts", mounts, selectedMounts, "selectedMounts");

            Object.keys(toolsByFolder).forEach(folder => {
                const folderId = `selectedToolsFolder_${folder}`;
                addOptionGroup(`Tools - ${folder}`, [toolsByFolder[folder]], selectedToolsFolder[folder], folderId);
            });

            draw();
        }

        function renderOptionGroup(label, options, id, selected, onChange) {
            const group = document.createElement("div");
            group.className = "select-group";

            const labelElem = document.createElement("label");
            labelElem.innerText = label;
            group.appendChild(labelElem);

            const select = document.createElement("select");
            select.id = id;
            select.multiple = true;
            select.size = 5;
            select.addEventListener("change", onChange);

            options.forEach((option, i) => {
                const opt = document.createElement("option");
                opt.value = i;
                opt.innerText = option;
                if (selected.includes(i)) opt.selected = true;
                select.appendChild(opt);
            });

            group.appendChild(select);
            return group;
        }

        const frameSize = 64;
        const numAnimations = 56;
        const animationSpeed = 250;

        const framesPerAnimationArray = [
            6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 8, 8, 8, 1, 1, 1, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 9, 8, 9, 8, 9, 8, 2, 2, 2, 6, 6, 6
        ];

        const drawPositions = {
            "Player_Base": [0, 0],
            "Chest": [0, 0],
            "Legs": [0, 0],
            "Feet": [0, 0],
            "Hands": [0, 0],
            "Hair": [0, 0],
            "Accessories": [0, 0],
            "Player_Mounts": [0, 50],
            "Tools": [0, 0]
        };

        const toolFolderFileOffsets = {
            "Utility": {
                "Iron_Tools": [0, 32],
                "Fishing_Rod": {
                    "default": [0, 44]
                },
                "default": [0, 0]
            },
            "Combat": {
                "Bow": {
                    "default": [0, 29]
                },
                "Sword": {
                    "Iron_Sword": [0, 6],
                    "default": [0, 0]
                },
                "default": [0, 0]
            },
            "Other": {
                "Lantern": {
                    "Lantern_Idle": [0, 20],
                    "Lantern_Running": [0, 23],
                    "default": [0, 0]
                },
                "Torch": {
                    "Torch_Idle": [0, 20],
                    "Torch_Running": [0, 23],
                    "default": [0, 0]
                },
                "default": [0, 0]
            }
        };

        const meleeToolNames = ["Sword"]; // Add all melee tool base names you have
        const rangedToolNames = ["Bow"]; // Add all ranged tool base names you have
        const fishingToolNames = ["Fishing_Rod"]; // Add all fishing tool base names you have
        const utilityToolNames = ["Tools"]; // Add all utility tool base names you have
        const idleToolNames = ["Idle"]; // Add all idle tool base names you have
        const runningToolNames = ["Running"]; // Add all running tool base names you have

        const mountAnimations = [50, 51, 52, 53, 54, 55, 56];

        const meleeAnimations = [6, 7, 8, 9, 10, 11, 12, 13, 14];
        const rangedAnimations = [29, 30, 31];
        const fishingAnimations = [44, 45, 46, 47, 48, 49];
        const utilityAnimations = [32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43];
        const idleAnimations = [20, 21, 22];
        const runningAnimations = [23, 24, 25];

        function draw() {
            bodyCtx.clearRect(0, 0, bodyCanvas.width, bodyCanvas.height);
            const bodyImgFiles = [];
            toolsCtx.clearRect(0, 0, toolsCanvas.width, toolsCanvas.height);
            const toolsImgFiles = [];

            function collect(arr, selected, name) {
                if (arr === mounts && selected[0] === 0) return;

                selected.forEach(index => {
                    const fileObj = arr[0][index];
                    if (index > 0 && fileObj && fileObj.file) {
                        let [x, y] = drawPositions[name] || [0, 0];
                        bodyImgFiles.push({ file: fileObj.file, x: x * frameSize, y: y * frameSize });
                    }
                });
            }

            collect(playerBase, selectedPlayerBase, "Player_Base");
            collect(chest, selectedChest, "Chest");
            collect(legs, selectedLegs, "Legs");
            collect(feet, selectedFeet, "Feet");
            collect(hands, selectedHands, "Hands");
            collect(hair, selectedHair, "Hair");
            collect(accessories, selectedAccessories, "Accessories");
            collect(mounts, selectedMounts, "Player_Mounts");

            Object.keys(toolsByFolder).forEach(folder => {
                const toolList = toolsByFolder[folder];
                const selectedList = selectedToolsFolder[folder];

                selectedList.forEach(index => {
                    const fileObj = toolList[index];
                    if (index > 0 && fileObj && fileObj.file) {
                        let [x, y] = drawPositions["Tools"];
                        const toolName = fileObj.name.split(".")[0]; // e.g. "Iron_Sword"
                        const folderOffsets = toolFolderFileOffsets[folder] || {};

                        // Function to find nested offsets by partial matching:
                        function findOffsets(folderOffsets, toolName) {
                            const categories = Object.keys(folderOffsets).filter(cat => cat !== "default");

                            // 1. Exact match: toolName === category
                            if (categories.includes(toolName)) {
                                const catOffsets = folderOffsets[toolName];
                                if (Array.isArray(catOffsets)) {
                                    return catOffsets;
                                } else if (catOffsets && typeof catOffsets === "object") {
                                    if (toolName in catOffsets) {
                                        return catOffsets[toolName];
                                    }
                                    if ("default" in catOffsets) {
                                        return catOffsets["default"];
                                    }
                                }
                            }

                            // 2. Suffix or prefix matching with category name
                            for (const category of categories) {
                                if (toolName.endsWith(`_${category}`) || toolName.startsWith(`${category}_`)) {
                                    const catOffsets = folderOffsets[category];
                                    if (typeof catOffsets === "object" && catOffsets !== null) {
                                        if (toolName in catOffsets) {
                                            return catOffsets[toolName];
                                        }

                                        if ("default" in catOffsets) {
                                            return catOffsets["default"];
                                        }
                                    }
                                }
                            }

                            // 3. Fallback: folder-level direct match
                            if (toolName in folderOffsets) {
                                return folderOffsets[toolName];
                            }

                            // 4. Fallback: folder-level default
                            return folderOffsets["default"] || [0, 0];
                        }


                        const [tx, ty] = findOffsets(folderOffsets, toolName);

                        x = tx;
                        y = ty;

                        toolsImgFiles.push({ file: fileObj.file, x: x * frameSize, y: y * frameSize });
                    }
                });
            });


            renderBody(bodyImgFiles, 0);
            renderTools(toolsImgFiles, 0);

            createCombinedAnimationsPerAnimation();
            createFullExportedCanvasFromActiveAnimations();
        }

        function renderBody(imgs, index) {
            if (index >= imgs.length) {
                createAnimationFromBodyCanvas();
                createCombinedAnimationsPerAnimation();
                createFullExportedCanvasFromActiveAnimations();
                return;
            }

            const img = new Image();
            img.src = URL.createObjectURL(imgs[index].file);
            img.onload = () => {
                bodyCtx.drawImage(img, imgs[index].x, imgs[index].y);
                renderBody(imgs, index + 1);
            };
        }

        function renderTools(imgs, index) {
            if (index >= imgs.length) {
                createAnimationFromToolsCanvas();
                createCombinedAnimationsPerAnimation();
                createFullExportedCanvasFromActiveAnimations();
                return;
            }

            const img = new Image();
            img.src = URL.createObjectURL(imgs[index].file);
            img.onload = () => {
                toolsCtx.drawImage(img, imgs[index].x, imgs[index].y);
                renderTools(imgs, index + 1);
            };
        }

        function hasSelectedTool(folderName, toolNames) {
            if (!selectedToolsFolder[folderName]) return false;
            const selectedIndices = selectedToolsFolder[folderName];
            const toolList = toolsByFolder[folderName] || [];

            return selectedIndices.some(index => {
                if (index === 0) return false; // index 0 is 'none'``
                const toolName = toolList[index]?.name || "";
                return toolNames.some(name => toolName.includes(name));
            });
        }

        function createAnimationFromBodyCanvas() {
            const container = document.getElementById('animationsBody');
            container.innerHTML = '';

            const framesByAnimation = [];

            const skipMounts = selectedMounts.length === 1 && selectedMounts[0] === 0;
            // Detect if melee or ranged tools are selected
            const hasMelee = hasSelectedTool("Combat", meleeToolNames);
            const hasRanged = hasSelectedTool("Combat", rangedToolNames);
            const hasFishing = hasSelectedTool("Utility", fishingToolNames)
            const hasUtility = hasSelectedTool("Utility", utilityToolNames)
            const hasIdle = hasSelectedTool("Other", idleToolNames)
            const hasRunning = hasSelectedTool("Other", runningToolNames)

            for (let animIndex = 0; animIndex < numAnimations; animIndex++) {
                if (skipMounts && mountAnimations.includes(animIndex)) continue;
                if (!hasMelee && meleeAnimations.includes(animIndex)) continue;
                if (!hasRanged && rangedAnimations.includes(animIndex)) continue;
                if (!hasFishing && fishingAnimations.includes(animIndex)) continue;
                if (!hasUtility && utilityAnimations.includes(animIndex)) continue;
                if (!hasIdle && idleAnimations.includes(animIndex)) continue;
                if (!hasRunning && runningAnimations.includes(animIndex)) continue;

                const frameCount = framesPerAnimationArray[animIndex];
                const frames = [];

                for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                    const frameCanvas = document.createElement('canvas');
                    frameCanvas.width = frameSize;
                    frameCanvas.height = frameSize;
                    const frameCtx = frameCanvas.getContext('2d');

                    frameCtx.drawImage(
                        body_canvas,
                        frameIndex * frameSize,
                        animIndex * frameSize,
                        frameSize,
                        frameSize,
                        0,
                        0,
                        frameSize,
                        frameSize
                    );

                    if (document.getElementById('toggleNumbers')?.checked) {
                        frameCtx.fillStyle = 'white';
                        frameCtx.font = '8px sans-serif';
                        frameCtx.fillText(animIndex, 2, 10);
                    }
                    frameCanvas.id = animIndex
                    frames.push(frameCanvas);
                }

                framesByAnimation.push(frames);
            }

            framesByAnimation.forEach((frames) => {
                const animCanvas = document.createElement('canvas');

                // Assign animCanvas id from the first frameCanvas id
                if (frames.length > 0) {
                    animCanvas.id = `anim-${frames[0].id}`;
                }

                animCanvas.width = frameSize;
                animCanvas.height = frameSize;

                const animCtx = animCanvas.getContext('2d');
                container.appendChild(animCanvas);

                let currentFrame = 0;
                setInterval(() => {
                    animCtx.clearRect(0, 0, frameSize, frameSize);
                    animCtx.drawImage(frames[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % frames.length;
                }, animationSpeed);
            });
        }

        function createAnimationFromToolsCanvas() {
            const container = document.getElementById('animationsTools');
            container.innerHTML = '';

            const framesByAnimation = [];

            const skipMounts = selectedMounts.length === 1 && selectedMounts[0] === 0;
            // Detect if melee or ranged tools are selected
            const hasMelee = hasSelectedTool("Combat", meleeToolNames);
            const hasRanged = hasSelectedTool("Combat", rangedToolNames);
            const hasFishing = hasSelectedTool("Utility", fishingToolNames)
            const hasUtility = hasSelectedTool("Utility", utilityToolNames)
            const hasIdle = hasSelectedTool("Other", idleToolNames)
            const hasRunning = hasSelectedTool("Other", runningToolNames)

            for (let animIndex = 0; animIndex < numAnimations; animIndex++) {
                if (skipMounts && mountAnimations.includes(animIndex)) continue;
                if (!hasMelee && meleeAnimations.includes(animIndex)) continue;
                if (!hasRanged && rangedAnimations.includes(animIndex)) continue;
                if (!hasFishing && fishingAnimations.includes(animIndex)) continue;
                if (!hasUtility && utilityAnimations.includes(animIndex)) continue;
                if (!hasIdle && idleAnimations.includes(animIndex)) continue;
                if (!hasRunning && runningAnimations.includes(animIndex)) continue;

                const frameCount = framesPerAnimationArray[animIndex];
                const frames = [];

                for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                    const frameCanvas = document.createElement('canvas');
                    frameCanvas.width = frameSize;
                    frameCanvas.height = frameSize;
                    const frameCtx = frameCanvas.getContext('2d');

                    frameCtx.drawImage(
                        tools_canvas,
                        frameIndex * frameSize,
                        animIndex * frameSize,
                        frameSize,
                        frameSize,
                        0,
                        0,
                        frameSize,
                        frameSize
                    );

                    if (document.getElementById('toggleNumbers')?.checked) {
                        frameCtx.fillStyle = 'white';
                        frameCtx.font = '8px sans-serif';
                        frameCtx.fillText(animIndex, 2, 10);
                    }
                    frameCanvas.id = animIndex
                    frames.push(frameCanvas);
                }

                framesByAnimation.push(frames);
            }

            framesByAnimation.forEach((frames) => {
                const animCanvas = document.createElement('canvas');

                // Assign animCanvas id from the first frameCanvas id
                if (frames.length > 0) {
                    animCanvas.id = `anim-${frames[0].id}`;
                }

                animCanvas.width = frameSize;
                animCanvas.height = frameSize;

                const animCtx = animCanvas.getContext('2d');
                container.appendChild(animCanvas);

                let currentFrame = 0;
                setInterval(() => {
                    animCtx.clearRect(0, 0, frameSize, frameSize);
                    animCtx.drawImage(frames[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % frames.length;
                }, animationSpeed);
            });
        }

        // Only the animation numbers here will have body drawn first.
        // All others will have tools drawn first.
        const bodyLastAnimations = [12, 13, 14, 22, 25, 31, 34, 37, 40, 43, 48, 49, 51, 55]; // whatever numbers should be last
        const bodyFirstAnimations = Array.from({ length: 56 }, (_, i) => i)
            .filter(i => !bodyLastAnimations.includes(i));

        function createCombinedAnimationsPerAnimation() {
            const container = document.getElementById('animationsCombined');
            container.innerHTML = '';

            const skipMounts = selectedMounts.length === 1 && selectedMounts[0] === 0;
            const hasMelee = hasSelectedTool("Combat", meleeToolNames);
            const hasRanged = hasSelectedTool("Combat", rangedToolNames);
            const hasFishing = hasSelectedTool("Utility", fishingToolNames);
            const hasUtility = hasSelectedTool("Utility", utilityToolNames);
            const hasIdle = hasSelectedTool("Other", idleToolNames);
            const hasRunning = hasSelectedTool("Other", runningToolNames);

            for (let animIndex = 0; animIndex < numAnimations; animIndex++) {
                if (skipMounts && mountAnimations.includes(animIndex)) continue;
                if (!hasMelee && meleeAnimations.includes(animIndex)) continue;
                if (!hasRanged && rangedAnimations.includes(animIndex)) continue;
                if (!hasFishing && fishingAnimations.includes(animIndex)) continue;
                if (!hasUtility && utilityAnimations.includes(animIndex)) continue;
                if (!hasIdle && idleAnimations.includes(animIndex)) continue;
                if (!hasRunning && runningAnimations.includes(animIndex)) continue;

                const frameCount = framesPerAnimationArray[animIndex];
                const combinedFrames = [];

                // Default false, true if animIndex in array
                const bodyFirst = bodyFirstAnimations.includes(animIndex);

                for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                    const combinedCanvas = document.createElement('canvas');
                    combinedCanvas.width = frameSize;
                    combinedCanvas.height = frameSize;
                    const combinedCtx = combinedCanvas.getContext('2d');

                    if (bodyFirst) {
                        combinedCtx.drawImage(
                            body_canvas,
                            frameIndex * frameSize,
                            animIndex * frameSize,
                            frameSize,
                            frameSize,
                            0,
                            0,
                            frameSize,
                            frameSize
                        );
                        combinedCtx.drawImage(
                            tools_canvas,
                            frameIndex * frameSize,
                            animIndex * frameSize,
                            frameSize,
                            frameSize,
                            0,
                            0,
                            frameSize,
                            frameSize
                        );
                    } else {
                        combinedCtx.drawImage(
                            tools_canvas,
                            frameIndex * frameSize,
                            animIndex * frameSize,
                            frameSize,
                            frameSize,
                            0,
                            0,
                            frameSize,
                            frameSize
                        );
                        combinedCtx.drawImage(
                            body_canvas,
                            frameIndex * frameSize,
                            animIndex * frameSize,
                            frameSize,
                            frameSize,
                            0,
                            0,
                            frameSize,
                            frameSize
                        );
                    }

                    if (document.getElementById('toggleNumbers')?.checked) {
                        combinedCtx.fillStyle = 'white';
                        combinedCtx.font = '8px sans-serif';
                        combinedCtx.fillText(animIndex, 2, 10);
                    }

                    combinedFrames.push(combinedCanvas);
                }

                const animCanvas = document.createElement('canvas');
                animCanvas.id = `combined-anim-${animIndex}`;
                animCanvas.width = frameSize;
                animCanvas.height = frameSize;
                container.appendChild(animCanvas);

                const animCtx = animCanvas.getContext('2d');

                let currentFrame = 0;
                setInterval(() => {
                    animCtx.clearRect(0, 0, frameSize, frameSize);
                    animCtx.drawImage(combinedFrames[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % combinedFrames.length;
                }, animationSpeed);
            }
        }


        function createFullExportedCanvasFromActiveAnimations() {
            try {
                const container = document.getElementById('animationsCombined');
                if (!container) {
                    console.warn("No #animationsCombined container found.");
                    return;
                }

                const bodyCanvas = window.body_canvas;
                const toolsCanvas = window.tools_canvas;
                if (!bodyCanvas || !toolsCanvas) {
                    console.error("body_canvas or tools_canvas not found.");
                    return;
                }

                // Try to get animation indices from the canvases in #animationsCombined
                let animCanvases = Array.from(container.querySelectorAll('canvas'));
                let animIndices = [];
                if (animCanvases.length) {
                    animIndices = animCanvases
                        .map(c => {
                            const m = c.id.match(/combined-anim-(\d+)/);
                            return m ? parseInt(m[1], 10) : NaN;
                        })
                        .filter(i => Number.isFinite(i));
                }

                // Fallback: if there are no canvases in the container, build indices via your same filters
                if (animIndices.length === 0) {
                    const skipMounts = selectedMounts.length === 1 && selectedMounts[0] === 0;
                    const hasMelee = hasSelectedTool("Combat", meleeToolNames);
                    const hasRanged = hasSelectedTool("Combat", rangedToolNames);
                    const hasFishing = hasSelectedTool("Utility", fishingToolNames);
                    const hasUtility = hasSelectedTool("Utility", utilityToolNames);
                    const hasIdle = hasSelectedTool("Other", idleToolNames);
                    const hasRunning = hasSelectedTool("Other", runningToolNames);

                    for (let animIndex = 0; animIndex < numAnimations; animIndex++) {
                        if (skipMounts && mountAnimations.includes(animIndex)) continue;
                        if (!hasMelee && meleeAnimations.includes(animIndex)) continue;
                        if (!hasRanged && rangedAnimations.includes(animIndex)) continue;
                        if (!hasFishing && fishingAnimations.includes(animIndex)) continue;
                        if (!hasUtility && utilityAnimations.includes(animIndex)) continue;
                        if (!hasIdle && idleAnimations.includes(animIndex)) continue;
                        if (!hasRunning && runningAnimations.includes(animIndex)) continue;
                        animIndices.push(animIndex);
                    }
                }

                if (animIndices.length === 0) {
                    console.warn("No animations detected to export.");
                    return;
                }

                // Build animFrames and find max frames
                const animFrames = [];
                let maxFrames = 0;
                for (const animIndex of animIndices) {
                    const frameCount = framesPerAnimationArray[animIndex];
                    if (!frameCount || frameCount <= 0) {
                        console.warn(`Skipping anim ${animIndex} (no frames).`);
                        continue;
                    }
                    animFrames.push({ animIndex, frameCount });
                    if (frameCount > maxFrames) maxFrames = frameCount;
                }

                if (animFrames.length === 0) {
                    console.warn("No valid animation frames found to export.");
                    return;
                }

                // Create final canvas
                const finalCanvas = document.createElement('canvas');
                finalCanvas.id = 'final_canvas';
                finalCanvas.className = 'final_canvas';
                finalCanvas.width = maxFrames * frameSize;
                finalCanvas.height = animFrames.length * frameSize;

                const finalCtx = finalCanvas.getContext('2d');
                // For pixel art you probably want no smoothing
                if (finalCtx) finalCtx.imageSmoothingEnabled = false;

                // Draw frames directly into final canvas using the same combine order as createCombinedAnimationsPerAnimation
                const bodyFirstArray = Array.isArray(window.bodyFirstAnimations) ? window.bodyFirstAnimations : [];

                for (let row = 0; row < animFrames.length; row++) {
                    const { animIndex, frameCount } = animFrames[row];
                    const bodyFirst = bodyFirstArray.includes(animIndex);
                    const dy = row * frameSize;

                    for (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {
                        const sx = frameIndex * frameSize;
                        const sy = animIndex * frameSize;
                        const dx = frameIndex * frameSize;

                        if (bodyFirst) {
                            finalCtx.drawImage(bodyCanvas, sx, sy, frameSize, frameSize, dx, dy, frameSize, frameSize);
                            finalCtx.drawImage(toolsCanvas, sx, sy, frameSize, frameSize, dx, dy, frameSize, frameSize);
                        } else {
                            finalCtx.drawImage(toolsCanvas, sx, sy, frameSize, frameSize, dx, dy, frameSize, frameSize);
                            finalCtx.drawImage(bodyCanvas, sx, sy, frameSize, frameSize, dx, dy, frameSize, frameSize);
                        }
                    }
                }

                // Insert/replace in export container safely
                const exportContainer = document.getElementById('final-exported-canvas');
                if (!exportContainer) {
                    console.error("#final-exported-canvas not found.");
                    return;
                }
                const oldCanvas = exportContainer.querySelector('#final_canvas');
                if (oldCanvas) exportContainer.replaceChild(finalCanvas, oldCanvas);
                else exportContainer.appendChild(finalCanvas);

                console.log("Export complete â€” final_canvas appended to #final-exported-canvas");
                return finalCanvas;
            } catch (err) {
                console.error("Error while creating export:", err);
            }
        }


        const downloadButton = document.getElementById('download-sprite');

        downloadButton.addEventListener('click', () => {
            const finalCanvas = document.getElementById('final_canvas');
            if (!finalCanvas) {
                alert('Canvas not ready yet!');
                return;
            }
            const dataURL = finalCanvas.toDataURL('image/png');

            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'sprite-sheet.png';
            link.click();
        });

    </script>

    <!-- Bootstrap JS (Optional) -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.3/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

    <style>
        /* ===== Global Styles ===== */
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }

        h1,
        h2,
        h3 {
            font-weight: 600;
        }

        /* ===== Header Buttons ===== */
        .header {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            transition: 0.2s ease;
        }

        .btn-primary {
            background-color: #1a73e8;
            /* A vibrant, fresh blue */
            color: white;
        }

        .btn-primary:hover {
            background-color: #155ab6;
            /* Darker shade for hover */
        }

        .btn-secondary {
            background-color: #495057;
            /* A deep slate gray */
            color: white;
        }

        .btn-secondary:hover {
            background-color: #343a40;
            /* Even darker for hover */
        }


        /* ===== Selection Panel ===== */
        #selection {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 25px;
        }

        .select-group {
            background: #242424;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.25);
            min-width: 180px;
        }

        .select-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .select-group select {
            width: 100%;
            min-height: 150px;
            padding: 6px 8px;
            font-size: 14px;
            border-radius: 6px;
            border: none;
            outline: none;
            background-color: #1a1a1a;
            color: white;
            box-shadow: inset 0px 1px 3px rgba(0, 0, 0, 0.4);
            transition: background 0.2s;

            overflow-y: auto;
            scrollbar-width: thin;
            /* Firefox */
            scrollbar-color: #1a73e8 #1a1a1a;
            /* Firefox colors */
        }

        .select-group select:hover {
            background-color: #2a2a2a;
        }

        /* Highlight for selected options */
        .select-group select option:checked {
            background-color: #1a73e8 !important;
            color: white;
        }

        /* ===== Canvas Containers ===== */
        .containers {
            display: inline-block;
            margin-bottom: 20px;
        }

        .final_canvas,
        .canvas-style-base {
            border-radius: 8px;
            background: #1a1a1a;
            border: 2px solid #444;
            /* half the actual width */
            width: 333px;
            /* keep aspect ratio */
            height: auto;
            vertical-align: top;
            /* Hidden until assets are loaded */
            display: inline-block;
        }

        /* Animation previews */
        #animationsBody,
        #animationsTools,
        #animationsCombined {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #animationsBody canvas,
        #animationsTools canvas,
        #animationsCombined canvas {
            border-radius: 6px;
            border: 1px solid #444;
            background: #1a1a1a;
            width: 80px;
            height: auto;
            margin: 5px;
            transition: transform 0.15s ease;
        }

        #animationsBody canvas:hover,
        #animationsTools canvas:hover,
        #animationsCombined canvas:hover {
            transform: scale(1.05);
        }

        #animationsBody,
        #animationsTools {
            display: none;
        }
    </style>
</body>

</html>